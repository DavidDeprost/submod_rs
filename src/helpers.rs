use std::path::{Path, PathBuf};
use std::ffi::OsStr;

use regex::Regex;
use failure::Error;


pub fn get_paths<'a>(input: &'a str, seconds: f64, partial: bool, rename: bool,
        output_opt: Option<&str>, convert_opt: Option<&str>)
    -> Result<(&'a Path, PathBuf, Option<PathBuf>), Error>
{
    // Create full path for inputfile:
    let input_path = Path::new(input); // creates Path that references input!

    // Return output early when user specified it with `--out` flag:
    if let Some(file) = output_opt {
        let output_path = Path::new(file).to_owned();
        return Ok( (input_path, output_path, None) );
    }

    // Find parent: path without filename
    // => parent will be empty if the path consists of the filename alone
    let parent = input_path.parent()
        .ok_or(format_err!("Invalid value for '\u{001b}[33m<INPUT>\u{001b}[0m': incorrect path"))?;

    // Create output file name and full path:
    let output_name = smart_name(input_path, seconds, partial, convert_opt)?;
    let output_path = parent.join(output_name); // creates owned PathBuf!

    // Create an optional rename in case user specified `--overname` flag:
    let mut rename_opt = None;
    if rename {
        rename_opt = smart_rename(input_path);
        if rename_opt == None {
            return Err(format_err!("Invalid value for '\u{001b}[33m<INPUT>\u{001b}[0m': invalid file name"));
        }
    }

    return Ok( (input_path, output_path, rename_opt) );
}

/// This functions smartly formats the default output file name,
/// such that output files that are reused as input still receive a sane name,
/// without any redundant extra suffixes from repeated calls.
fn smart_name(input_path: &Path, mut seconds: f64, partial: bool,
    convert_opt: Option<&str>) -> Result<String, Error>
{
    let mut stem = input_path.file_stem().unwrap().to_str().unwrap();
    let mut extension = input_path.extension().unwrap().to_str().unwrap();
    if let Some(to_ext) = convert_opt {
        extension = to_ext;
    }
    if let Some(i) = stem.find("__[Original]") {
        stem = &stem[..i];
    }
    // '-' indicates that only part of the file was modified:
    let partial = if partial { "-" } else { "+" };
    // Regex to check if the inputfile was generated by submod:
    let tag = Regex::new(r"__\[[+-]\d+\.\d+_Sec[+-]\]")?;
    let was_processed: bool = tag.is_match(stem);

    if was_processed {
        // Extract the increment number from the filename, and add it to seconds:
        seconds += Regex::new(r"[+-]\d+\.\d+")? // regex for finding number in filename
            .captures(stem).unwrap() // unwrap capture groups corresponding to the leftmost match
            .get(0).unwrap() // take out entire match and unwrap from Option
            .as_str().parse::<f64>()?; // convert to str and then to float

        let tag_start = tag.find(stem).unwrap().start();
        stem = &stem[..tag_start];
    }

    let output = if seconds >= 0.0 {
        format!("{}__[+{:.2}_Sec{}].{}", stem, seconds, partial, extension)
    } else {
        format!("{}__[{:.2}_Sec{}].{}", stem, seconds, partial, extension)
    };

    return Ok(output);
}

fn smart_rename(input_path: &Path) -> Option<PathBuf> {
    if input_path.to_str()?.contains("__[Original].") {
        Some(input_path.to_owned())
    } else {
        let original = input_path.file_stem()
            .and_then(OsStr::to_str)?
            .to_owned() + "__[Original]." +
                input_path.extension()
                .and_then(OsStr::to_str)?;
        let original_path = input_path.parent()?.join(original); // creates owned PathBuf!
        Some(original_path)
    }
}

pub fn is_srt_or_vtt(input: String) -> Result<(), String> {
    if input.ends_with(".srt") || input.ends_with(".vtt") {
        return Ok(());
    }
    Err(String::from("incorrect file extension\n\n\
        Only \u{001b}[32m.srt\u{001b}[0m or \u{001b}[32m.vtt\u{001b}[0m files are allowed."))
}

pub fn is_float(seconds: String) -> Result<(), String> {
    // Ideally, we should be able to return the f64 in Ok variant,
    // but this most likely requires more advanced `dyn` or `impl` returns
    if let Ok(_) = seconds.parse::<f64>() {
        Ok(())
    } else {
        Err("should be a number".to_string())
    }
}

pub fn is_timing(time_string: String) -> Result<(), String> {
    let result: Result<Vec<_>, _> = time_string.rsplit(":")
        .map(|t| t.parse::<f64>())
        .collect(); // use collect() on iterator of Result<T, E>s to see if any of them failed!

    match result {
        Ok(_) => Ok(()),
        Err(_) => Err(String::from("incorrect time formatting\n\n\
            Use ':' to separate hours, minutes and seconds, like so:\n    \
            \u{001b}[32mhh:mm:ss\u{001b}[0m to specify hours, minutes and seconds\n       \
            \u{001b}[32mmm:ss\u{001b}[0m to only specify minutes and seconds\n          \
            \u{001b}[32mss\u{001b}[0m to only specify seconds"))
    }
}

pub fn report_error(error: Error) {
    eprintln!("\u{001b}[38;5;208mError:\u{001b}[0m {}\n", error);
    println!("USAGE:\n    \
                submod [FLAGS] [OPTIONS] <filename> <seconds>\n        \
                    <filename>   (Path to) .srt or .vtt subtitle file to modify\n        \
                    <seconds>    seconds to add or subtract from time encoding\n\n\
                    For more information try \u{001b}[32msubmod --help\u{001b}[0m");
}

pub fn report_success(deleted_subs: i32, output_path: &Path, overwrite: bool, rename_opt: Option<PathBuf>) {
    println!("\u{001b}[32;1mSuccess.\u{001b}[0m");

    if deleted_subs > 0 {
        if deleted_subs == 1 {
            println!("    \u{001b}[41;1m ! \u{001b}[0m   One subtitle was deleted at the beginning of the file.");
        } else {
            println!("    \u{001b}[41;1m ! \u{001b}[0m   {} subtitles were deleted at the beginning of the file.",
                deleted_subs);
        }
    }
    if let Some(rename) = rename_opt {
        println!(" The input file was renamed to `{}`.", rename.display());
    } else if overwrite {
        println!(" The input file was overwritten.");
    }

    println!(" Output: \u{001b}[1m \u{001b}[48;5;238m {} \u{001b}[0m", output_path.display());
}